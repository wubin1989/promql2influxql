/**
* Generated by go-doudou v2.0.4.
* Don't edit!
 */
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"

	"github.com/go-resty/resty/v2"
	"github.com/opentracing-contrib/go-stdlib/nethttp"
	"github.com/opentracing/opentracing-go"
	"github.com/pkg/errors"
	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
	"github.com/wubin1989/promql2influxql/applications/prom/dto"
)

type PromClient struct {
	provider registry.IServiceProvider
	client   *resty.Client
	rootPath string
}

func (receiver *PromClient) SetRootPath(rootPath string) {
	receiver.rootPath = rootPath
}

func (receiver *PromClient) SetProvider(provider registry.IServiceProvider) {
	receiver.provider = provider
}

func (receiver *PromClient) SetClient(client *resty.Client) {
	receiver.client = client
}
func (receiver *PromClient) Query(ctx context.Context, _headers map[string]string, query string, time *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("query", fmt.Sprintf("%v", query))
	if time != nil {
		_urlValues.Set("time", fmt.Sprintf("%v", *time))
	}
	if timeout != nil {
		_urlValues.Set("timeout", fmt.Sprintf("%v", *timeout))
	}
	_path := "/query"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data   dto.QueryData `json:"data"`
		Status string        `json:"status"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, _result.Status, nil
}
func (receiver *PromClient) GetQuery(ctx context.Context, _headers map[string]string, query string, time *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("query", fmt.Sprintf("%v", query))
	if time != nil {
		_urlValues.Set("time", fmt.Sprintf("%v", *time))
	}
	if timeout != nil {
		_urlValues.Set("timeout", fmt.Sprintf("%v", *timeout))
	}
	_path := "/query"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data   dto.QueryData `json:"data"`
		Status string        `json:"status"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, _result.Status, nil
}
func (receiver *PromClient) Query_range(ctx context.Context, _headers map[string]string, query string, start *string, end *string, step *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("query", fmt.Sprintf("%v", query))
	if start != nil {
		_urlValues.Set("start", fmt.Sprintf("%v", *start))
	}
	if end != nil {
		_urlValues.Set("end", fmt.Sprintf("%v", *end))
	}
	if step != nil {
		_urlValues.Set("step", fmt.Sprintf("%v", *step))
	}
	if timeout != nil {
		_urlValues.Set("timeout", fmt.Sprintf("%v", *timeout))
	}
	_path := "/query_range"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data   dto.QueryData `json:"data"`
		Status string        `json:"status"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, _result.Status, nil
}
func (receiver *PromClient) GetQuery_range(ctx context.Context, _headers map[string]string, query string, start *string, end *string, step *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("query", fmt.Sprintf("%v", query))
	if start != nil {
		_urlValues.Set("start", fmt.Sprintf("%v", *start))
	}
	if end != nil {
		_urlValues.Set("end", fmt.Sprintf("%v", *end))
	}
	if step != nil {
		_urlValues.Set("step", fmt.Sprintf("%v", *step))
	}
	if timeout != nil {
		_urlValues.Set("timeout", fmt.Sprintf("%v", *timeout))
	}
	_path := "/query_range"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data   dto.QueryData `json:"data"`
		Status string        `json:"status"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, _result.Status, nil
}
func (receiver *PromClient) GetLabel_Label_nameValues(ctx context.Context, _headers map[string]string, start *string, end *string, match *[]string, label_name string) (_resp *resty.Response, data []string, status string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if start != nil {
		_urlValues.Set("start", fmt.Sprintf("%v", *start))
	}
	if end != nil {
		_urlValues.Set("end", fmt.Sprintf("%v", *end))
	}
	if match != nil {
		for _, _item := range *match {
			_urlValues.Add("match", fmt.Sprintf("%v", _item))
		}
	}
	_req.SetPathParam("label_name", fmt.Sprintf("%v", label_name))
	_path := "/label/{label_name}/values"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data   []string `json:"data"`
		Status string   `json:"status"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, _result.Status, nil
}

func NewPromClient(opts ...restclient.RestClientOption) *PromClient {
	defaultProvider := restclient.NewServiceProvider("PROM")
	defaultClient := restclient.NewClient()

	svcClient := &PromClient{
		provider: defaultProvider,
		client:   defaultClient,
	}

	for _, opt := range opts {
		opt(svcClient)
	}

	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
		return nil
	})

	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
		*request = *traceReq
		return nil
	})

	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
		return nil
	})

	return svcClient
}
