/**
* Generated by go-doudou v2.0.4.
* You can edit it as your need.
 */
package client

import (
	"context"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/rs/zerolog"
	"github.com/slok/goresilience"
	"github.com/slok/goresilience/circuitbreaker"
	rerrors "github.com/slok/goresilience/errors"
	"github.com/slok/goresilience/metrics"
	"github.com/slok/goresilience/retry"
	"github.com/slok/goresilience/timeout"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/zlogger"
	"github.com/wubin1989/promql2influxql/rpc/dto"
)

type RpcClientProxy struct {
	client *RpcClient
	logger zerolog.Logger
	runner goresilience.Runner
}

func (receiver *RpcClientProxy) Query(ctx context.Context, _headers map[string]string, query string, time *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, data, status, err = receiver.client.Query(
			ctx,
			_headers,
			query,
			time,
			timeout,
		)
		if err != nil {
			return errors.Wrap(err, "call Query fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call Query fail")
	}
	return
}
func (receiver *RpcClientProxy) GetQuery(ctx context.Context, _headers map[string]string, query string, time *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, data, status, err = receiver.client.GetQuery(
			ctx,
			_headers,
			query,
			time,
			timeout,
		)
		if err != nil {
			return errors.Wrap(err, "call GetQuery fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetQuery fail")
	}
	return
}
func (receiver *RpcClientProxy) Query_range(ctx context.Context, _headers map[string]string, query string, start *string, end *string, step *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, data, status, err = receiver.client.Query_range(
			ctx,
			_headers,
			query,
			start,
			end,
			step,
			timeout,
		)
		if err != nil {
			return errors.Wrap(err, "call Query_range fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call Query_range fail")
	}
	return
}
func (receiver *RpcClientProxy) GetQuery_range(ctx context.Context, _headers map[string]string, query string, start *string, end *string, step *string, timeout *string) (_resp *resty.Response, data dto.QueryData, status string, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, data, status, err = receiver.client.GetQuery_range(
			ctx,
			_headers,
			query,
			start,
			end,
			step,
			timeout,
		)
		if err != nil {
			return errors.Wrap(err, "call GetQuery_range fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetQuery_range fail")
	}
	return
}
func (receiver *RpcClientProxy) GetLabel_Label_nameValues(ctx context.Context, _headers map[string]string, start *string, end *string, match *[]string, label_name string) (_resp *resty.Response, data []string, status string, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, data, status, err = receiver.client.GetLabel_Label_nameValues(
			ctx,
			_headers,
			start,
			end,
			match,
			label_name,
		)
		if err != nil {
			return errors.Wrap(err, "call GetLabel_Label_nameValues fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetLabel_Label_nameValues fail")
	}
	return
}

type ProxyOption func(*RpcClientProxy)

func WithRunner(runner goresilience.Runner) ProxyOption {
	return func(proxy *RpcClientProxy) {
		proxy.runner = runner
	}
}

func WithLogger(logger zerolog.Logger) ProxyOption {
	return func(proxy *RpcClientProxy) {
		proxy.logger = logger
	}
}

func NewRpcClientProxy(client *RpcClient, opts ...ProxyOption) *RpcClientProxy {
	cp := &RpcClientProxy{
		client: client,
		logger: zlogger.Logger,
	}

	for _, opt := range opts {
		opt(cp)
	}

	if cp.runner == nil {
		var mid []goresilience.Middleware
		mid = append(mid, metrics.NewMiddleware("github.com/wubin1989/promql2influxql/rpc_client", metrics.NewPrometheusRecorder(prometheus.DefaultRegisterer)))
		mid = append(mid, circuitbreaker.NewMiddleware(circuitbreaker.Config{
			ErrorPercentThresholdToOpen:        50,
			MinimumRequestToOpen:               6,
			SuccessfulRequiredOnHalfOpen:       1,
			WaitDurationInOpenState:            5 * time.Second,
			MetricsSlidingWindowBucketQuantity: 10,
			MetricsBucketDuration:              1 * time.Second,
		}),
			timeout.NewMiddleware(timeout.Config{
				Timeout: 3 * time.Minute,
			}),
			retry.NewMiddleware(retry.Config{
				Times: 3,
			}))

		cp.runner = goresilience.RunnerChain(mid...)
	}

	return cp
}
