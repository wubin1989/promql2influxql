/**
* Generated by go-doudou v2.0.4.
* You can edit it as your need.
 */
package service

import (
	"context"
	"time"

	"github.com/unionj-cloud/go-doudou/v2/toolkit/cast"

	"github.com/pkg/errors"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/caller"
	"github.com/wubin1989/promql2influxql"
	"github.com/wubin1989/promql2influxql/command"
	"github.com/wubin1989/promql2influxql/promql"

	"github.com/wubin1989/promql2influxql/rpc/config"
	"github.com/wubin1989/promql2influxql/rpc/dto"
)

var _ Rpc = (*RpcImpl)(nil)

type RpcImpl struct {
	conf    *config.Config
	adaptor *promql2influxql.InfluxDBAdaptor
}

func (receiver *RpcImpl) query(ctx context.Context, query string, t *string, resultChan chan dto.QueryResponse, errChan chan error) {
	var ts *time.Time
	if t != nil {
		floatT, err := cast.ToFloat64E(*t)
		if err != nil {
			errChan <- errors.Wrap(err, caller.NewCaller().String())
			return
		}
		tmp := time.UnixMilli(int64(floatT * 1000))
		ts = &tmp
	}
	result, err := receiver.adaptor.Query(ctx, command.Command{
		Cmd:      query,
		Dialect:  promql.PROMQL_DIALECT,
		Database: receiver.conf.BizConf.AdaptorInfluxDatabase,
		Start:    ts,
		End:      ts,
		Timezone: time.Local,
	})
	if err != nil {
		errChan <- errors.Wrap(err, caller.NewCaller().String())
		return
	}
	runResult := result.(promql.RunResult)
	resultChan <- dto.QueryResponse{
		Data: dto.QueryData{
			Result:     runResult.Result,
			ResultType: runResult.ResultType,
		},
		Status: "success",
	}
}

var emptyResult = dto.QueryResponse{}

func (receiver *RpcImpl) Query(ctx context.Context, query string, t *string, timeout *string) (data dto.QueryData, status string, err error) {
	if timeout != nil {
		timeoutDuration, err := time.ParseDuration(*timeout)
		if err != nil {
			return emptyResult.Data, emptyResult.Status, errors.Wrap(err, caller.NewCaller().String())
		}
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeoutDuration)
		defer cancel()
	}
	resultChan := make(chan dto.QueryResponse)
	errChan := make(chan error)

	go func() {
		receiver.query(ctx, query, t, resultChan, errChan)
	}()

	for {
		select {
		case <-ctx.Done():
			return emptyResult.Data, emptyResult.Status, errors.Wrap(err, caller.NewCaller().String())
		case err := <-errChan:
			return emptyResult.Data, emptyResult.Status, errors.Wrap(err, caller.NewCaller().String())
		case resp := <-resultChan:
			return resp.Data, resp.Status, nil
		}
	}
}
func (receiver *RpcImpl) GetQuery(ctx context.Context, query string, time *string, timeout *string) (data dto.QueryData, status string, err error) {
	return receiver.Query(ctx, query, time, timeout)
}

func (receiver *RpcImpl) query_range(ctx context.Context, query string, start *string, end *string, step *string, resultChan chan dto.QueryResponse, errChan chan error) {
	var startTs, endTs *time.Time
	var err error
	if start != nil {
		floatT, err := cast.ToFloat64E(*start)
		if err != nil {
			errChan <- errors.Wrap(err, caller.NewCaller().String())
			return
		}
		tmp := time.UnixMilli(int64(floatT * 1000))
		startTs = &tmp
	}
	if end != nil {
		floatT, err := cast.ToFloat64E(*end)
		if err != nil {
			errChan <- errors.Wrap(err, caller.NewCaller().String())
			return
		}
		tmp := time.UnixMilli(int64(floatT * 1000))
		endTs = &tmp
	}
	cmd := command.Command{
		Cmd:      query,
		Dialect:  promql.PROMQL_DIALECT,
		Database: receiver.conf.BizConf.AdaptorInfluxDatabase,
		Start:    startTs,
		End:      endTs,
		Timezone: time.Local,
		DataType: command.GRAPH_DATA,
	}
	if step != nil {
		if cmd.Step, err = time.ParseDuration(*step + "s"); err != nil {
			errChan <- errors.Wrap(err, caller.NewCaller().String())
			return
		}
	}
	result, err := receiver.adaptor.Query(ctx, cmd)
	if err != nil {
		errChan <- errors.Wrap(err, caller.NewCaller().String())
		return
	}
	runResult := result.(promql.RunResult)
	resultChan <- dto.QueryResponse{
		Data: dto.QueryData{
			Result:     runResult.Result,
			ResultType: runResult.ResultType,
		},
		Status: "success",
	}
}

func (receiver *RpcImpl) Query_range(ctx context.Context, query string, start *string, end *string, step *string, timeout *string) (data dto.QueryData, status string, err error) {
	if timeout != nil {
		timeoutDuration, err := time.ParseDuration(*timeout)
		if err != nil {
			return emptyResult.Data, emptyResult.Status, errors.Wrap(err, caller.NewCaller().String())
		}
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeoutDuration)
		defer cancel()
	}
	resultChan := make(chan dto.QueryResponse)
	errChan := make(chan error)

	go func() {
		receiver.query_range(ctx, query, start, end, step, resultChan, errChan)
	}()

	for {
		select {
		case <-ctx.Done():
			return emptyResult.Data, emptyResult.Status, errors.Wrap(err, caller.NewCaller().String())
		case err := <-errChan:
			return emptyResult.Data, emptyResult.Status, errors.Wrap(err, caller.NewCaller().String())
		case resp := <-resultChan:
			return resp.Data, resp.Status, nil
		}
	}
}
func (receiver *RpcImpl) GetQuery_range(ctx context.Context, query string, start *string, end *string, step *string, timeout *string) (data dto.QueryData, status string, err error) {
	return receiver.Query_range(ctx, query, start, end, step, timeout)
}

func NewRpc(conf *config.Config, adaptor *promql2influxql.InfluxDBAdaptor) *RpcImpl {
	return &RpcImpl{
		conf:    conf,
		adaptor: adaptor,
	}
}
